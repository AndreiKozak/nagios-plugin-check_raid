#!/usr/bin/perl -w
# vim:ts=4
#
# Check RAID status.  Look for any known types
# of RAID configurations, and check them all.
# Return CRITICAL if in a DEGRADED state, since
# if the whole array has failed you'll have already noticed it!
# Return UNKNOWN if there are no RAID configs that can be found.
# Return WARNING if rebuilding or initialising
#
# S Shipway, university of auckland
#
# Thanks to M Carmier for megaraid section
#
# Version 1.1 : IPS; Solaris, AIX, Linux software RAID; megaide
# Version 2.0 : Added megaraid, mpt (serveraid), aacli (serveraid)
# Version 2.1 : Made script more generic and secure, Added gdth

use strict;
use Getopt::Long;
use vars qw($opt_v $opt_d $opt_h $opt_W $opt_S);
my(%ERRORS) = ( OK=>0, WARNING=>1, CRITICAL=>2, UNKNOWN=>3, WARN=>1, CRIT=>2 );
my($VERSION) = "2.1";
my($message, $status);
my(@ignore);

my $sudo = find_prog('sudo');
my $cat = find_prog('cat');

# various raids
my $mpt_status = find_prog('mpt-status');     # LSILogic MPT ServeRAID
my $aaccli = find_prog('aaccli');             # Adaptec ServeRAID
my $afacli = find_prog('afacli');             # Adaptec AACRAID
my $lsraid = find_prog('lsraid');             # Linux, software RAID
my $metastat = find_prog('metastat');         # Solaris, software RAID
my $lsvg = find_prog('lsvg');                 # AIX LVM
my $ipssend = find_prog('ipssend');           # Serveraid IPS

#####################################################################
sub print_usage () {
	print "Usage: check_raid [list of devices to ignore]\n";
	print "       check_raid -v\n";
	print "       check_raid -h\n";
}

sub print_help () {
	print "check_raid, Revision: $VERSION \n";
	print "Copyright (c) 2004-2006 S Shipway, Copyright (c) 2009, Elan Ruusam√§e <glen\@delfi.ee>
This plugin reports the current server's RAID status
";
	print_usage();
}

#####################################################################
# return true if parameter is not in ignore list
sub valid($) {
	my($v) = $_[0];
	$v = lc $v;
	foreach ( @ignore ) { return 0 if((lc $_) eq $v); }
	return 1;
}

#####################################################################
sub check_metastat {
	my($l,$s,$d,$sd);

	my @CMD = $metastat;
	unshift(@CMD, $sudo) if $> and $sudo;

	open(my $fh , '-|', @CMD) or return;
	while (<$fh>) {
		chomp;
		if (/^(\S+):/) { $d = $1; $sd = ''; next; }
		if (/Submirror \d+:\s+(\S+)/) { $sd = $1; next; }
		if (my($s) = /State: (\S.+)/) {
			if ($sd and valid($sd) and valid($d)) {
				if ($s =~ /Okay/i) {
					# no worries...
				} elsif ($s =~ /Resync/i) {
					$status = $ERRORS{WARNING} unless $status;
				} else {
					$status = $ERRORS{ERROR};
				}
				$message .= "$d:$sd:$s ";
			}
		}
	}
	close $fh;
}

sub check_megaide {
	my $fh;
	foreach my $f (glob('/proc/megaide/*/status')) {
		if (-r $f) {
			open $fh, '<', $f or next;
	   	} else {
		   	my @CMD = ($cat, $f);
			unshift(@CMD, $sudo) if $> and $sudo;
			open($fh , '-|', @CMD) or next;
	   	}
		while (<$fh>) {
			if (my($s, $n) = /Status\s*:\s*(\S+).*Logical Drive.*:\s*(\d+)/i) {
				next unless valid($n);
				if ($s ne 'ONLINE') {
					$status = $ERRORS{CRITICAL};
					$message .= "Megaide:$n:$s ";
				} else {
					$message .= "Megaide:$n:$s ";
				}
				last;
			}
		}
		close $fh;
	}
}

sub check_mdstat {
	my($n,$f);

	open my $fh, '<', '/proc/mdstat' or return;
	while (<$fh>) {
		if (/^(\S+)\s+:/ ) { $n = $1; $f = ''; next; }
		if (/(\S+)\[\d+\]\(F\)/ ) { $f = $1; next; }
		if (my($s) = /\s*.*\[([U_]+)\]/ ) {
			next unless valid($n);
			if ($s =~ /_/) {
				$status = $ERRORS{CRITICAL};
				$message .= "md:$n:$f:$s ";
			} else {
				$message .= "md:$n:$s ";
			}
		}
	}
	close $fh;
}

sub check_lsraid {
	my @CMD = ($lsraid, '-A', '-p');
	unshift(@CMD, $sudo) if $> and $sudo;

	open(my $fh , '-|', @CMD) or return;
	while (<$fh>) {
		chomp;
		if (my($n, $s) = m{/dev/(\S+) \S+ (\S+)}) {
			next unless valid($n);
			if ($s =~ /good|online/) {
			   	# no worries
			} elsif ($s =~ /sync/) {
				$status = $ERRORS{WARNING} unless $status;
			} else {
			   	$status = $ERRORS{CRITICAL};
		   	}
			$message .= "md:$n:$s ";
		}
	}
	close $fh;
}

sub check_vg {
	my @CMD = $lsvg;
	unshift(@CMD, $sudo) if $> and $sudo;

	my @vg;
	open(my $fh , '-|', @CMD) or return;
	while (<$fh>) {
	   	chomp;
	   	push @vg, $_;
   	}
	close $fh;

	foreach my $vg (@vg) {
		next unless valid($vg); # skip entire VG

		open(my $fh , '-|', @CMD, '-l', $vg) or next;

		while (<$fh>) {
			my @f = split /\s/;
		   	my ($n, $s) = ($f[0],$f[5]);
			next if (!valid($n) or !$s);
			next if ($f[3] eq $f[2]); # not a mirrored LV

			if ($s =~ /open\/(\S+)/i) {
				$s = $1;
				if ($s ne 'syncd') {
				   	$status = $ERRORS{CRITICAL};
			   	}
				$message .= "lvm:$n:$s ";
			}
		}
		close $fh;
	}
}

sub check_ips {
	my @CMD = $ipssend;
	unshift(@CMD, $sudo) if $> and $sudo;

	my $n;
	open(my $fh , '-|', @CMD) or return;
	while (<$fh>) {
		chomp;
		if (/drive number (\d+)/i ) { $n = $1; next; }
		next unless valid($n);

		if (my($s, $c) = /Status .*: (\S+)\s+(\S+)/ ) {
			if ($c =~ /SYN|RBL/i ) { # resynching
				$status = $ERRORS{WARNING} unless $status;
			} elsif ($c !~ /OKY/i) { # not OK
				$status = $ERRORS{CRITICAL};
			}
			$message .= "ips:$n:$s ";
		}
	}
	close $fh;
}

sub check_aaccli {
	my @CMD = $aaccli;
	unshift(@CMD, $sudo) if $> and $sudo;

	use IPC::Open2;

	my ($read, $write);
	my $pid = open2($read, $write, @CMD) or return;
	print $write "open aac0\n";
	print $write "container list /full\n";
	print $write "exit\n";
	close $write;
#File foo receiving all output.
#
#AAC0>
#COMMAND: container list /full=TRUE
#Executing: container list /full=TRUE
#Num          Total  Oth Stripe          Scsi   Partition                                       Creation
#Label Type   Size   Ctr Size   Usage   C:ID:L Offset:Size   State   RO Lk Task    Done%  Ent Date   Time
#----- ------ ------ --- ------ ------- ------ ------------- ------- -- -- ------- ------ --- ------ --------
# 0    Mirror 74.5GB            Open    0:02:0 64.0KB:74.5GB Normal                        0  051006 13:48:54
# /dev/sda             Auth             0:03:0 64.0KB:74.5GB Normal                        1  051006 13:48:54
#
#
#AAC0>
#COMMAND: logfile end
#Executing: logfile end
	while (<$read>) {
		if (my ($dsk, $stat) = /(\d:\d\d?:\d+)\s+\S+:\S+\s+(\S+)/) {
			next unless valid($dsk);
			$dsk =~ s/:/\//g;
			next unless valid($dsk);
			$message .= "aac:$dsk:$stat ";
			$status = $ERRORS{CRITICAL} if ($stat eq "Broken");
			$status = $ERRORS{WARNING} if (!$status and $stat eq "Rebuild");
			$status = $ERRORS{WARNING} if (!$status and $stat eq "Bld/Vfy");
			$status = $ERRORS{CRITICAL} if ($stat eq "Missing");
			$status = $ERRORS{WARNING} if (!$status and $stat eq "Verify");
			$status = $ERRORS{WARNING} if (!$status and $stat eq "VfyRepl");
		}
	}
	close $read;
}

sub check_afacli {
	my @CMD = $afacli;
	unshift(@CMD, $sudo) if $> and $sudo;

	use IPC::Open2;

	my ($read, $write);
	my $pid = open2($read, $write, @CMD) or return;
	print $write "open afa0\n";
	print $write "container list /full\n";
	print $write "exit\n";
	close $write;

	while (<$read>) {
		if (my ($dsk, $stat) = /(\d:\d\d?:\d+)\s+\S+:\S+\s+(\S+)/) {
			next unless valid($dsk);
			$dsk =~ s/:/\//g;
			next unless valid($dsk);
			$message .= "aac:$dsk:$stat ";
			$status = $ERRORS{CRITICAL} if ($stat eq "Broken");
			$status = $ERRORS{WARNING} if (!$status and $stat eq "Rebuild");
			$status = $ERRORS{WARNING} if (!$status and $stat eq "Bld/Vfy");
			$status = $ERRORS{CRITICAL} if ($stat eq "Missing");
			$status = $ERRORS{WARNING} if (!$status and $stat eq "Verify");
			$status = $ERRORS{WARNING} if (!$status and $stat eq "VfyRepl");
		}
	}
	close $read;
}

sub check_mpt {
	my @CMD = $mpt_status;
	unshift(@CMD, $sudo) if $> and $sudo;

	open(my $fh , '-|', @CMD) or return;
	while (<$fh>) {
		next unless (my($dsk, $stat) = /vol_id\s*(\d+).*state\s+(\S+),/);
		next unless valid($dsk);
		$message .= "mpt:$dsk:$stat ";
		if (!$status and $stat =~ /INITIAL|INACTIVE|RESYNC/) {
			$status = $ERRORS{WARNING};
		} elsif ($stat =~ /DEGRADED/) {
			$status = $ERRORS{CRITICAL};
		} elsif (!$status and $stat !~ /ONLINE/) {
			$status = $ERRORS{UNKNOWN};
		}
	}
	close $fh;
}

sub check_megaraid {
	my $fh;
	foreach my $f (glob('/proc/megaraid/*/raiddrives*')) {
		if (-r $f) {
			open $fh, '<', $f or next;
	   	} else {
		   	my @CMD = ($cat, $f);
			unshift(@CMD, $sudo) if $> and $sudo;
			open($fh , '-|', @CMD) or next;
	   	}
		while (<$fh>) {
			if (my($n, $s) = /logical drive\s*:\s*(\d+).*, state\s*:\s*(\S+)/i) {
				next unless valid($n);
				if ($s ne 'optimal') {
					$status = $ERRORS{CRITICAL};
					$message .= "Megaraid:$n:$s ";
				} else {
					$message .= "Megaraid:$n:$s ";
				}
				last;
			}
		}
		close $fh;
	}
}

# based on check_gdth by Petter Reinholdtsen
# http://homepages.uni-paderborn.de/odenbach/projects/check_gdth/
sub check_gdth {
# Looking for this text block:
# Logical Drives:
#  Number:        0               Status:         ok
#  Capacity [MB]: 17333           Type:           RAID-1
#  Slave Number:  15              Status:         ok
#  Missing Drv.:  0               Invalid Drv.:   0
#  To Array Drv.: --
	for my $file (</proc/scsi/gdth/*>) {
		open my $fh, '<', $file or return;
		my ($controller) = $file =~ m{([^/]+$)};
		while (<$fh>) {
			chomp;
			last if (/Array Drives:/); # Stop after the Logical Drive block
			if (my ($num, $status) = m/^\s+Number:\s+(\d+)\s+Status:\s+(\S+)$/) {
				if ("ok" ne $status) {
					$status = $ERRORS{CRITICAL} unless $status;
					$message .= "gdth:$controller:$num($status) ";
				} else {
					$message .= "gdth:$controller:$num($status) ";
				}
			}
		}
		close($fh);
	}
}

sub find_prog {
	my $prog = shift;

    my @paths = split /:/, $ENV{'PATH'};
    unshift(@paths, qw(/usr/local/nrpe /usr/local/bin /sbin /usr/sbin /bin /usr/sbin));

	for my $path (@paths) {
		return "$path/$prog" if -x "$path/$prog";
	}
	return undef;
}

sub find_file {
	for my $file (@_) {
		return $file if -f $file;
	}
	return undef;
}

###########################################################################
sub sudoers {
	# build values to be added
	my @sudo;
    push(@sudo, "CHECK_RAID  ALL=(root) NOPASSWD: $ipssend getconfig 1 LD\n") if $ipssend;
    push(@sudo, "CHECK_RAID  ALL=(root) NOPASSWD: $aaccli container list /full\n") if $aaccli;
    push(@sudo, "CHECK_RAID  ALL=(root) NOPASSWD: $mpt_status\n") if $mpt_status and -d "/proc/mpt";
	push(@sudo, "CHECK_RAID  ALL=(root) NOPASSWD: $cat /proc/megaide/0/status\n") if -d "/proc/megaide/0";
	push(@sudo, "CHECK_RAID  ALL=(root) NOPASSWD: $cat /proc/megaide/1/status\n") if -d "/proc/megaide/1";
	foreach my $mr (glob('/proc/mega*/*/raiddrives*')) {
		push(@sudo, "CHECK_RAID  ALL=(root) NOPASSWD: $cat $mr\n") if -d $mr;
	}

	unless (@sudo) {
		print "Your configuration does not need to use sudo, sudoers not updated\n";
		return;
	}

	my $sudoers = find_file('/usr/local/etc/sudoers', '/etc/sudoers');
	my $visudo = find_prog('visudo');

	die "Unable to find sudoers file.\n" unless -f $sudoers;
	die "Unable to write to sudoers file.\n" unless -w $sudoers;
	die "visudo program not found\n" unless -x $visudo;
	die "cat program not found\n" unless -x $cat;

	print "Updating file $sudoers\n";

	# NOTE: secure as visudo itself: /etc is root owned
	my $new = $sudoers.".new.".$$;

	# setup to have sane perm for new sudoers file
	umask(0227);

	# insert old sudoers
	open my $old, '<', $sudoers or die $!;
	open my $fh, '>', $new or die $!;
	while (<$old>) {
		print $fh $_;
	}
	close $old or die $!;

	# setup alias, so we could easily remove these later by matching lines with 'CHECK_RAID'
	# also this avoids installing ourselves twice.
	print $fh "\n";
	print $fh "# Lines matching CHECK_RAID added by $0 -S on ", scalar localtime, "\n";
	print $fh "User_Alias CHECK_RAID=nagios\n";
	print $fh @sudo;

	close $fh;

	# validate sudoers
	system($visudo, '-c', '-f', $new) == 0 or unlink($new),exit $? >> 8;

	# use the new file
	rename($new, $sudoers) or die $!;

	print "$sudoers file updated.\n";
}

#####################################################################
$ENV{'BASH_ENV'}='';
$ENV{'ENV'}='';

Getopt::Long::Configure('bundling');
GetOptions
	("v"   => \$opt_v, "version"    => \$opt_v,
	 "h"   => \$opt_h, "help"       => \$opt_h,
	 "d" => \$opt_d, "debug" => \$opt_d,
	 "S" => \$opt_S, "sudoers" => \$opt_S,
	 "W" => \$opt_W, "warnonly" => \$opt_W );

if($opt_S) {
	sudoers;
	exit 0;
}

@ignore = @ARGV if(@ARGV);

if ($opt_v) {
	print "check_raid Version $VERSION\n" ;
	exit $ERRORS{'OK'};
}
if ($opt_h) {
	print_help();
	exit $ERRORS{'OK'};
}
if ($opt_W) {
	$ERRORS{CRITICAL} = $ERRORS{WARNING};
}

$status = $ERRORS{OK}; $message = '';

check_gdth if -d "/proc/scsi/gdth";                     # Linux Gdth RAID
check_megaide if -d "/proc/megaide";                    # MegaIDE RAID controller
check_mdstat  if -f "/proc/mdstat";                     # Linux LVM
check_mpt     if $mpt_status and -d "/proc/mpt";        # LSILogic MPT ServeRAID
check_megaraid if -d "/proc/megaraid";                  # MegaRAID
check_aaccli if $aaccli and -d "/proc/scsi/aacraid";    # Adaptec ServeRAID
check_afacli  if $afacli;                               # Adaptec AACRAID
check_lsraid  if $lsraid;                               # Linux, software RAID
check_metastat if $metastat;                            # Solaris, software RAID
check_vg      if $lsvg;                                 # AIX LVM
check_ips     if $ipssend;                              # Serveraid IPS
# Can't do megaRAID controller, it needs X and java (yuck)

if( $message ) {
	if( $status == $ERRORS{OK} ) {
		print "OK: ";
	} elsif( $status == $ERRORS{WARNING} ) {
		print "WARNING: ";
	} elsif( $status == $ERRORS{CRITICAL} ) {
		print "CRITICAL: ";
	}
	print "$message\n";
} else {
	$status = $ERRORS{UNKNOWN};
	print "No RAID configuration found.\n";
}
exit $status;
